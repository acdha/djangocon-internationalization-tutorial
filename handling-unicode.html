<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><![endif]-->
        <meta name="viewport" content="width=1024, user-scalable=no">

        <title>Building Global Websites</title>

        <!-- Required stylesheet -->
        <link rel="stylesheet" href="deck.js/core/deck.core.css">


        <link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
        <link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
        <link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
        <link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
        <link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">

        <link rel="stylesheet" href="deck.js/themes/style/swiss.css">

        <link rel="stylesheet" href="custom.css">

        <script src="deck.js/modernizr.custom.js"></script>
    </head>

    <body class="deck-container">
        <section class="slide">
            <h1>Handling Unicode</h1>

            <p class="center bottom">Background: <a href="http://docs.python.org/howto/unicode.html" title="Unicode HOWTO">http://docs.python.org/howto/unicode.html</a></p>
        </section>

        <section class="slide" id="unicode-in-python2">
            <h2>Unicode in Python 2.x</h2>
            <p>
                There's a persistent misconception that you need Python 3 to
                support Unicode. This is untrue: the default <code>""</code>
                may produce a <code>str</code> (i.e. bytes without a specified
                encoding) instance but simply prefixing any string with
                <code>u</code> produces a full <code>unicode</code> object.
            </p>
            <p>Python 2 will even helpfully convert them when you mix the two:</p>

            <samp class="block">
                &gt;&gt;&gt; type(&quot;foo&quot;)<br>
                &lt;type &#x27;<b>str</b>&#x27;&gt;<br>
                &gt;&gt;&gt; type(u&quot;bar&quot;)<br>
                &lt;type &#x27;<b>unicode</b>&#x27;&gt;<br>
                &gt;&gt;&gt; &quot;foo&quot; + u&quot;bar&quot;<br>
                u&#x27;foobar&#x27;
            </samp>

            <p class="center">Not so bad, right?</p>
        </section>

        <section class="slide" id="unicode-in-python2-the-bad-parts">
            <h2>Unicode in Python 2.x: the bad parts</h2>

            <p>
                To preserve compatibility with existing code, Python 2 assumes
                byte-strings are ASCII. This means that any input source is a
                risk of <code>UnicodeDecodeError</code>s:
            </p>

            <samp class="block">
                &gt;&gt;&gt; s = &quot; &quot;.join([&#x27;I&#x27;, <b class="mistake">'\xe2\x98\xba'</b>, &#x27;Unicode&#x27;])<br>
                &gt;&gt;&gt; print s  <i># Raw UTF-8 displays correctly in my UTF-8 terminal</i><br>
                I &#x263A; Unicode<br>
                &gt;&gt;&gt; unicode(s)<br>
                Traceback (most recent call last):<br>
                  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>
                UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe2 in position 2: ordinal not in range(128)<br>
            </samp>

            <p>Everything works if you know the encoding and remember to decode first:</p>
            <samp class="block">
                &gt;&gt;&gt; s.decode(&quot;utf-8&quot;)<br>
                u&#x27;I \u263a Unicode&#x27;
            </samp>

        </section>

        <section class="slide" id="unicode-in-python3">
            <h2>Unicode in Python 3.x</h2>
            <h3>Explicit is better than implicit</h3>

            <p>
                Learning from what was problematic in Python 2, the default
                string type is <code>unicode</code>, with a separate
                <code>bytes</code> type for raw I/O. You can't mix the two
                without an explicit conversion:
            </p>

            <samp class="block">
                &gt;&gt;&gt; &quot;☹&quot; + b&quot;bytes&quot;<br>
                Traceback (most recent call last):<br>
                  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>
                TypeError: Can&#x27;t convert &#x27;bytes&#x27; object to str implicitly<br>
                &gt;&gt;&gt; &quot;☺&quot; + b&quot; bytes&quot;.decode(&quot;ascii&quot;)<br>
                &#x27;☺ bytes&#x27;<br>
                &gt;&gt;&gt; &quot;&#x263A;&quot;.encode(&quot;utf-8&quot;) + b&quot; bytes&quot;<br>
                b&#x27;\xe2\x98\xba bytes&#x27;<br>
            </samp>

            <p class="center">Python 2 fails later; Python 3 forces you to fix it now</p>
        </section>

        <section class="slide" id="unicode-best-practices">
            <h2>Unicode Best Practices</h2>

            <p class="center note">These rules are the same for Python 2 and 3 so you won't need to change when Django migrates</p>

            <ul>
                <li>
                    <strong>Always use Unicode internally</strong>
                </li>
                <li>
                    <strong>Always convert to Unicode as soon as you receive something and encode it when you send it</strong>
                </li>
                <li>
                    <strong>Decide how to handle invalid values</strong>
                </li>
            </ul>
        </section>

        <section class="slide" id="unicode-conversion">
            <h2>Unicode Best Practices</h2>
            <h3>I/O Conversion</h3>

            <p>
                The most basic form involves str and anything str-like where
                you want to convert everything as soon as you see it:
            </p>
            <code class="block">
                s = foo.read().decode("utf-8")<br>
                print >>foo, s.encode("utf-8")
            </code>

            <p>
                For files, you might want to use the <a
                href="http://docs.python.org/library/codecs.html">codecs</a>
                module so you can read from the file normally and receive
                Unicode characters instead of byte-strings:
            </p>
            <samp class="block">
                &gt;&gt;&gt; import codecs<br>
                &gt;&gt;&gt; with codecs.open(foo_file, encoding=&quot;utf-8&quot;) as f:<br>
                &gt;&gt;&gt;     &hellip;
            </samp>
        </section>

        <section class="slide" id="invalid-unicode">
            <h2>Unicode Best Practices</h2>
            <h3>Handling invalid data</h3>

            <p>
                In general the best policy is to reject invalid text so the
                user can correct it immediately. However, in a batch context
                you might need to process what you can. Python allows you to
                “ignore” or strip anything which fails to decode:
            </p>

            <code class="block">foo.decode("utf-8", "ignore")</code>

            <p>
                It may be preferable to instead replace each invalid character
                with the
                <a href="http://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">Unicode Replacement character �</a>
                to clearly indicate that data was lost:
            </p>

            <code class="block">foo.decode("utf-8", "replace")</code>
        </section>

        <section class="slide" id="unicode-normalization">
            <h2>Unicode Best Practices</h2>
            <h3><a href="http://unicode.org/faq/normalization.html">Normalization</a></h3>

            <p>
                There are <a href="background.html#terminology-unicode-2">multiple ways to
                display many characters</a>, producing situations where a
                program treats two values as different even though they appear
                identical to the user. We can avoid this problem by normalizing
                everything to a consistent internal representation for
                comparison:
            </p>
            <samp class="block">
                &gt;&gt;&gt; from unicodedata import normalize<br>
                &gt;&gt;&gt; precomposed = u&quot;\N{LATIN SMALL LETTER E WITH ACUTE}&quot;
                &gt;&gt;&gt; decomposed = u&quot;\N{LATIN SMALL LETTER E}\N{COMBINING ACUTE ACCENT}&quot;<br>
                &gt;&gt;&gt; precomposed == decomposed<br>
                False<br>
                &gt;&gt;&gt; normalize(&quot;NFC&quot;, precomposed) == normalize(&quot;NFC&quot;, decomposed)<br>
                True
            </samp>
        </section>

        <section class="slide" id="unicode-numeric-value">
            <h2>Other tricks from Python's unicodedata module</h2>
            <h3>Comparing numbers with Unicode</h3>

            <p>
                Python's <a href="http://docs.python.org/library/unicodedata.html">unicodedata</a>
                module has other features for working with Unicode text. Several of them allow you
                to retrieve information about characters, as in this example which generated the
                different characters in the
                <a href="background.html#terminology-unicode-2">numeric equivalence example</a>:
            </p>
            <code class="block">
            from __future__ import print_function, unicode_literals<br>
            from unicodedata import decimal<br>
            import sys<br>
            <br>
            if sys.version_info[0] == 3:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;unichr = chr<br>
            <br>
            for i in range(0, sys.maxunicode):<br>
            &nbsp;&nbsp;&nbsp;&nbsp;u = unichr(i)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if decimal(u, None) == 5:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(u.encode("utf-8"))<br>
            </code>
        </section>

        <section class="slide" id="re-vs-regex">
            <h2>Unicode Best Practices</h2>
            <h3>re vs. regex</h3>
        </section>

        <section class="slide" id="unicode-in-django">
            <h2>Unicode in Django</h2>

            <ol>
                <li>smart_unicode / smart_str</li>
                <li>Watch those database defaults</li>
            </ol>
        </section>

        <section class="slide" id="django-normalization">
            <h2>Normalizing your data</h2>

        </section>

        <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
        <a href="#" class="deck-next-link" title="Next">&#8594;</a>

        <!-- deck.status snippet -->
        <p class="deck-status">
            <span class="deck-status-current"></span>
            /
            <span class="deck-status-total"></span>
        </p>

        <!-- deck.goto snippet -->
        <form action="." method="get" class="goto-form">
            <label for="goto-slide">Go to slide:</label>
            <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
            <datalist id="goto-datalist"></datalist>
            <input type="submit" value="Go">
        </form>

        <!-- deck.hash snippet -->
        <a href="." title="Permalink to this slide" class="deck-permalink">#</a>


        <script src="deck.js/jquery-1.7.2.min.js"></script>
        <script src="deck.js/core/deck.core.js"></script>

        <script src="deck.js/core/deck.core.js"></script>
        <script src="deck.js/extensions/hash/deck.hash.js"></script>
        <script src="deck.js/extensions/menu/deck.menu.js"></script>
        <script src="deck.js/extensions/goto/deck.goto.js"></script>
        <script src="deck.js/extensions/status/deck.status.js"></script>
        <script src="deck.js/extensions/navigation/deck.navigation.js"></script>

        <script>
            $(function() {
                $.deck('.slide');
            });
        </script>
    </body>
</html>
